import tkinter as tk
import os
import hashlib
import yara
from termcolor import colored
from datetime import datetime

def load_rules(signatures_folder,output_text):
    if not os.path.exists(signatures_folder):
        output_text.delete(0, tk.END)
        output_text.insert(tk.END, "Signatures folder not browse.\n")
        output_text.itemconfigure(tk.END, fg="red")
        return None
    rule_files = {os.path.splitext(f)[0]: os.path.join(signatures_folder, f) for f in os.listdir(signatures_folder) if f.endswith('.yara') and os.path.isfile(os.path.join(signatures_folder, f))}
    if len(rule_files) == 0:
        output_text.delete(0, tk.END)
        output_text.insert(tk.END, "No YARA files found in signatures folder.\n")
        output_text.itemconfigure(tk.END, fg="red")
        
        return None
    rules = yara.compile(filepaths=rule_files)

    return rules

def is_file_malicious(file_path, rules):
    with open(file_path, 'rb') as file:
        file_data = file.read()
        matches = rules.match(data=file_data)
        if matches:
            file_hash = hashlib.md5(file_data).hexdigest()
            return True, file_hash
        else:
            return False, None
            
            
def scan_files(directory_path, signatures_folder, output_text):
    rules = load_rules(signatures_folder,output_text)
    if not rules:
        return []

    malicious_files = []
    for root, directories, files in os.walk(directory_path):
        for file in files:
            file_path = os.path.join(root, file)
            #output_text.insert(tk.END, "Scanning directory: {} \n\n".format(directory_path))
            output_text.insert(tk.END, "Scanning file: {}".format(file_path))
            output_text.insert(tk.END, "\n\n")

            is_malicious, file_hash = is_file_malicious(file_path, rules)
            
            if is_malicious:
                file_size = os.path.getsize(file_path)
                last_modified_time = datetime.fromtimestamp(os.path.getmtime(file_path)).strftime('%Y-%m-%d %H:%M:%S')
                malicious_files.append((file_path, file_size, last_modified_time, file_hash))
                output_text.insert(tk.END, "Result => File -- {}".format(file_path) + " -- is a malicious file")
                output_text.itemconfigure(tk.END, fg="red")
                output_text.insert(tk.END, "\n\n")
                output_text.insert(tk.END, "---------------\n\n")
                output_text.itemconfigure(tk.END, fg="gray")
            else:
                output_text.insert(tk.END, "Result => File -- {}".format(file_path) + " -- is not a malicious file")
                output_text.insert(tk.END, "\n\n")
                output_text.insert(tk.END, "---------------\n\n")
                output_text.itemconfigure(tk.END, fg="gray")

    # sort malicious files by filename
    sorted_malicious_files = sorted(malicious_files, key=lambda x: x[0])

    return sorted_malicious_files

def scan_file(file_path, signatures_folder, output_text):
    rules = load_rules(signatures_folder,output_text)
    if not rules:
        return []
    
    is_malicious, file_hash = is_file_malicious(file_path, rules)
    if is_malicious:
        file_size = os.path.getsize(file_path)
        last_modified_time = datetime.fromtimestamp(os.path.getmtime(file_path)).strftime('%Y-%m-%d %H:%M:%S')
        malicious_files = [(file_path, file_size, last_modified_time, file_hash)]
    else:
        malicious_files = []
        output_text.insert(tk.END, "Result => File -- {}".format(file_path) + " -- is not a malicious file")
        output_text.insert(tk.END, "\n\n")
        
    return malicious_files
